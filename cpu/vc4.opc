/* -- opc.h */

/* Most bits in the first word are variable, but we can at least hash on
   coarse instruction types, which is better than nothing.  */

#define CGEN_DIS_HASH_SIZE 8
#define CGEN_DIS_HASH(buf, value)					\
  ((((unsigned char *) buf)[1] & 0x80) == 0 ? 0      /* scalar16.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf8 ? 1 /* vector80.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf0 ? 2 /* vector48.  */	\
   : (((unsigned char *) buf)[1] & 0xf0) == 0xe0 ? 3 /* scalar48.  */	\
   : 4)						     /* scalar32.  */

#define CGEN_ASM_HASH_SIZE 5

#define CGEN_VERBOSE_ASSEMBLER_ERRORS

typedef enum
{
  H,
  HX,
  HY,
  V,
  VX,
  VY,
  DASH
} vc4_vec_dir;

#define SRU_BIT  0x40
#define ENA_BIT  0x20
#define HIGH_BIT 0x10
#define SIGN_BIT 0x08
#define CLRA_BIT 0x04
#define WBA_BIT  0x02
#define SUB_BIT  0x01

/* -- asm.c */

#include <errno.h>

union floatbits {
  float f;
  uint32_t u;
};

static const char *
parse_floatimm6 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 const char **strp,
		 int opindex ATTRIBUTE_UNUSED,
		 unsigned long *valuep)
{
  const char *startptr;
  char *endptr;
  union floatbits val;
  unsigned int exponent, signbit, mantissa;

  if (**strp == '#')
    (*strp)++;

  startptr = *strp;

  errno = 0;
  val.f = (float) strtod (startptr, &endptr);

  if (errno != 0)
    goto err_out;

  signbit = (val.u & 0x80000000) ? 1 : 0;
  exponent = (val.u >> 23) & 0xff;
  mantissa = val.u & 0x7fffff;

  if (exponent >= 124 && exponent < 132
      && (mantissa & 0x1fffff) == 0)
    {
      exponent -= 124;
      *valuep = (signbit << 5) | (exponent << 2) | (mantissa >> 21);
      *strp = endptr;
      return NULL;
    }

err_out:
  return "Bad floating-point immediate";
}

static const char *
parse_shifted_uimm (CGEN_CPU_DESC cd, const char **strp, int opindex,
		    unsigned long *valuep, unsigned bits, unsigned shift)
{
  const char *errmsg;
  unsigned mask = (1 << shift) - 1;
  unsigned long hi = 1 << bits;
  enum cgen_parse_operand_result result_type;
  unsigned long value;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  /* Ambiguity resolution: (rN++) looks like adding an expression "+", which
     fails to parse as an address.  */
  if (**strp == '+')
    return "post-inc";

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  if (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER)
    return "use wider reloc";

  value = result;

  if (!errmsg && ((value & mask) != 0 || (value >> shift) >= hi))
    errmsg = "out-of-range immediate";
  else
    *valuep = value;

  return errmsg;
}

static const char *
parse_uimm5 (CGEN_CPU_DESC cd, const char **strp, int opindex,
	     unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 0);
}

static const char *
parse_uimm4_shl2 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 4, 2);
}

static const char *
parse_uimm5_shl2 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 2);
}

static const char *
parse_uimm5_shl3 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 3);
}

static const char *
parse_shifted_imm (CGEN_CPU_DESC cd, const char **strp, int opindex,
		   long *valuep, unsigned bits, unsigned shift)
{
  const char *errmsg;
  unsigned mask = (1 << shift) - 1;
  long lo = -(1 << (bits - 1)), hi = 1 << (bits - 1);
  enum cgen_parse_operand_result result_type;
  long value;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  /* Ambiguity resolution: (rN++) looks like adding an expression "+", which
     fails to parse as an address.  */
  if (**strp == '+')
    return "post-inc";

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  if (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER)
    return "use wider reloc";

  if (result & 0x80000000)
    result |= ~(bfd_vma) 0xffffffff;

  value = (bfd_signed_vma) result;

  if (!errmsg && ((value & mask) != 0 || (value >> shift) < lo
		  || (value >> shift) >= hi))
    errmsg = "out-of-range immediate";
  else
    *valuep = value;

  return errmsg;
}

#define SHIFTED_IMM_FN(B,S)						\
  static const char *							\
  parse_imm##B##_shl##S (CGEN_CPU_DESC cd, const char **strp,		\
			 int opindex, long *valuep)			\
  {									\
    return parse_shifted_imm (cd, strp, opindex, valuep, (B), (S));	\
  }

SHIFTED_IMM_FN (6, 8)
SHIFTED_IMM_FN (6, 7)
SHIFTED_IMM_FN (6, 6)
SHIFTED_IMM_FN (6, 5)
SHIFTED_IMM_FN (6, 4)
SHIFTED_IMM_FN (6, 3)
SHIFTED_IMM_FN (6, 2)
SHIFTED_IMM_FN (6, 1)

SHIFTED_IMM_FN (16, 4)
SHIFTED_IMM_FN (16, 3)
SHIFTED_IMM_FN (16, 2)
SHIFTED_IMM_FN (16, 1)

static const char *
parse_imm4 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 4, 0);
}

static const char *
parse_imm6 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 6, 0);
}

static const char *
parse_imm12 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 12, 0);
}

static const char *
parse_imm16 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 16, 0);
}

static const char *
parse_imm27 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 27, 0);
}

static const char *
parse_imm32 (CGEN_CPU_DESC cd, const char **strp, int opindex,
             unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  *valuep = (unsigned long) result;

  return 0;
}

static const char *
parse_pcrel27 (CGEN_CPU_DESC cd, const char **strp, int opindex,
	       bfd_reloc_code_real_type code,
	       enum cgen_parse_operand_result *result_type, bfd_vma *valuep)
{
  bfd_vma result;
  const char *errmsg;

  /* Instructions like "st r5,(lr)" are ambiguous since "lr" can be interpreted
     as a bracketed symbolic name when we meant it to be parsed as a register
     indirection.  Special-case the former to fail.  */
  if (**strp == '(')
    {
      const char *s = *strp;

      if (s[0] == '-' && s[1] == '-')
        return "looks like predec";

      while (ISALNUM (*++s))
        ;

      if (s[0] == '+' && s[1] == '+')
        return "looks like postinc";

      if (*s == ')')
        return "looks like indirection";
    }

  errmsg = cgen_parse_address (cd, strp, opindex, code, result_type, &result);

  if (!errmsg)
    *valuep = result;

  return errmsg;
}

static const char *
parse_shlN (CGEN_CPU_DESC cd, const char **strp,
            int opindex,
            unsigned long *valuep ATTRIBUTE_UNUSED,
            unsigned long shift)
{
  const char *scan = *strp;
  bfd_boolean is_multiply = FALSE;
  const char *errmsg;
  unsigned long uval;

  while (ISSPACE (*scan))
    scan++;

  if (strncmp (scan, "shl", 3) == 0
      || strncmp (scan, "lsl", 3) == 0)
    scan += 3;
  else if (strncmp (scan, "<<", 2) == 0)
    scan += 2;
  else if (strncmp (scan, "*", 1) == 0)
    {
      scan++;
      is_multiply = TRUE;
    }
  else
    return "no left shift";

  while (ISSPACE (*scan))
    scan++;

  if (!is_multiply && *scan == '#')
    scan++;

  *strp = scan;
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &uval);

  if (errmsg)
    return errmsg;

  if ((is_multiply && uval == (1ul << shift))
      || (!is_multiply && uval == shift))
    return 0;

  return "wrong shift amount";
}

#define PARSE_SHLN(N)                                             \
  static const char *                                             \
  parse_shl##N (CGEN_CPU_DESC cd, const char **strp, int opindex, \
                unsigned long *valuep)                            \
  {                                                               \
    return parse_shlN (cd, strp, opindex, valuep, (N));           \
  }

PARSE_SHLN(1)
PARSE_SHLN(2)
PARSE_SHLN(3)
PARSE_SHLN(4)
PARSE_SHLN(5)
PARSE_SHLN(6)
PARSE_SHLN(7)
PARSE_SHLN(8)

static const char *
parse_unsigned_int_maybe_postinc (CGEN_CPU_DESC cd, const char **strp,
                                  int opindex, unsigned long *valuep,
                                  bfd_boolean *postinc_p)
{
  int nesting = 0;
  char *ptr = *strp;
  char *term = 0, saved_char;
  char *errmsg;

  *postinc_p = FALSE;

  while (*ptr != 0)
    {
      if (*ptr == '(')
        nesting++;
      else if (*ptr == ')')
        {
          if (nesting > 0)
            nesting--;
          else
            break;
        }
      else if (ptr[0] == '+' && ptr[1] == '+')
        {
          /* We have a postinc, but cgen_parse_unsigned_integer will misparse
             it.  Insert a zero-terminator temporarily as a workaround.  */
          term = ptr;
          saved_char = *ptr;
          *ptr = 0;
          break;
        }
      else if (*ptr == ',')
        break;
      ptr++;
    }

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (term)
    *ptr = saved_char;
  if (errmsg)
    return errmsg;

  if ((*strp)[0] == '+' && (*strp)[1] == '+')
    {
      (*strp) += 2;
      *postinc_p = TRUE;
    }

  return 0;
}

/* Vector insn parsing.

   This parses a vector operand and encodes bits as:

   19     16 15         10 9                   0
   [r r r r] [f f f f f f] [v v v v v v v v v v]
       |           |                 `-encoded coordinate.
       |            `-added scalar reg, column offset flag & post-inc.
        `-extra coordinate bits for A operand.
*/

static const char *
parse_vector_reg (CGEN_CPU_DESC cd, const char **strp, int opindex,
                  unsigned long *valuep, bfd_boolean areg_p)
{
  const char *ptr = *strp;
  vc4_vec_dir vec_dir;
  unsigned long y, x;
  const char *errmsg;
  unsigned long valbits = 0;
  bfd_boolean do_inc = FALSE;
  bfd_boolean column_offset = FALSE;
  bfd_boolean inc_here;
  unsigned scalar_reg = 15;

  if ((ptr[0] == 'H' && ptr[1] == 'X')
      || (ptr[0] == 'H' && ptr[1] == '1' && ptr[2] == '6'))
    vec_dir = HX;
  else if ((ptr[0] == 'H' && ptr[1] == 'Y')
           || (ptr[0] == 'H' && ptr[1] == '3' && ptr[2] == '2'))
    vec_dir = HY;
  else if (ptr[0] == 'H'
           || (ptr[0] == 'H' && ptr[1] == '8'))
    vec_dir = H;
  else if ((ptr[0] == 'V' && ptr[1] == 'X')
           || (ptr[0] == 'V' && ptr[1] == '1' && ptr[2] == '6'))
    vec_dir = VX;
  else if ((ptr[0] == 'V' && ptr[1] == 'Y')
           || (ptr[0] == 'V' && ptr[1] == '3' && ptr[2] == '2'))
    vec_dir = VY;
  else if (ptr[0] == 'V'
           || (ptr[0] == 'V' && ptr[1] == '8'))
    vec_dir = V;
  else
    return "expected H/HX/HY/V/VX/VY";

  /* H8/H16/H32 and V8/V16/V32 happen to each be one char longer than their
     H/HX/HY and V/VX/VY aliases.  */
  if (ISDIGIT (ptr[1]))
    ptr++;

  if (vec_dir == H || vec_dir == V)
    ptr++;
  else
    ptr += 2;

  if (*ptr != '(')
    return "expected '('";

  ptr++;

  *strp = ptr;
  errmsg = parse_unsigned_int_maybe_postinc (cd, strp, opindex, &y, &inc_here);
  if (errmsg)
    return errmsg;

  if (vec_dir == H || vec_dir == HX || vec_dir == HY)
    do_inc |= inc_here;
  else if (inc_here)
    return "can't increment vertical";

  if (**strp != ',')
    return "expected ,";
  (*strp)++;

  errmsg = parse_unsigned_int_maybe_postinc (cd, strp, opindex, &x, &inc_here);
  if (errmsg)
    return errmsg;

  if (vec_dir == V || vec_dir == VX || vec_dir == VY)
    do_inc |= inc_here;
  else if (inc_here)
    return "can't increment horizontal";

  ptr = *strp;
  if (*ptr != ')')
    return "expected ')'";

  ptr++;

  if (ptr[0] == '+' && ptr[1] == 'r')
    {
      unsigned long regno;
      int scanned, chars_read = 0;
      ptr += 2;
      scanned = sscanf (ptr, "%lu%n", &regno, &chars_read);
      if (scanned == 0)
        return "expecting register number";
      if (regno > 14)
        return "register out of range";
      ptr += chars_read;
      scalar_reg = regno;
    }

  if (*ptr == '*')
    {
      ptr++;
      column_offset = TRUE;
    }

  if (x > 63)
    return "X position out of range";

  if (y > 63)
    return "Y position out of range";

  switch (vec_dir)
    {
    case H:
      if (!areg_p && (x & 15) != 0)
        return "can't encode X position";
      valbits = y & 63;
      valbits |= (x >> 4) << 7;
      if (areg_p)
        valbits |= (x & 15) << 16;
      break;
    case HX:
      if ((!areg_p && (x & 31) != 0)
          || (areg_p && (x & 31) >= 16))
        return "can't encode X position";
      valbits = y & 63;
      valbits |= 0x200;
      valbits |= (x >> 5) << 7;
      if (areg_p)
        valbits |= (x & 15) << 16;
      break;
    case HY:
      if ((!areg_p && x != 0)
          || (areg_p && x >= 16))
        return "can't encode X position";
      valbits = y & 63;
      valbits |= 0x300;
      if (areg_p)
        valbits |= (x & 15) << 16;
      break;
    case V:
      if (!areg_p)
        {
          if ((y & 15) != 0)
            return "can't encode Y position";
          valbits = y & 0x30;
          valbits |= x & 15;
          valbits |= 0x40;
          valbits |= (x >> 4) << 7;
        }
      else
        {
          valbits = y & 63;
          valbits |= (x >> 4) << 7;
          valbits |= 0x40;
          valbits |= (x & 15) << 16;
        }
     break;
    case VX:
      if ((x & 31) >= 16)
        return "can't encode X position";
      if (!areg_p)
        {
          if ((y & 15) != 0)
            return "can't encode Y position";
          valbits = y & 0x30;
          valbits |= x & 15;
          valbits |= 0x240;
          valbits |= (x >> 5) << 7;
        }
      else
        {
          valbits = y & 63;
          valbits |= 0x240;
          valbits |= (x >> 5) << 7;
          valbits |= (x & 15) << 16;
        }
      break;
    case VY:
      if (x >= 16)
        return "can't encode X position";
      if (!areg_p)
        {
          if ((y & 15) != 0)
            return "can't encode Y position";
          valbits = y & 0x30;
          valbits |= x & 15;
          valbits |= 0x340;
        }
      else
        {
          valbits = y & 63;
          valbits |= 0x340;
          valbits |= (x & 15) << 16;
        }
      break;
    }

  if (column_offset)
    valbits |= 0x400;

  if (do_inc)
    valbits |= 0x800;

  valbits |= scalar_reg << 12;

  *valuep = valbits;
  *strp = ptr;

  return 0;
}

static const char *
parse_vec80aludreg (CGEN_CPU_DESC cd, const char **strp, int opindex,
                    unsigned long *valuep)
{
  return parse_vector_reg (cd, strp, opindex, valuep, FALSE);
}

static const char *
parse_vec80aluareg (CGEN_CPU_DESC cd, const char **strp, int opindex,
                    unsigned long *valuep)
{
  return parse_vector_reg (cd, strp, opindex, valuep, TRUE);
}

static const char *
parse_vec80alubreg (CGEN_CPU_DESC cd, const char **strp, int opindex,
                    unsigned long *valuep)
{
  return parse_vector_reg (cd, strp, opindex, valuep, FALSE);
}

static int
parse_scalar_reg_update (const char **strp, unsigned long *acc_sru, int opcode)
{
  int scanned, chars_read = 0;
  unsigned regno;

  if (**strp == ' ')
    (*strp)++;

  if (**strp != 'r')
    return 1;

  (*strp)++;

  scanned = sscanf (*strp, "%u%n", &regno, &chars_read);
  if (scanned == 0)
    return 1;

  if (regno > 7)
    return 1;

  *acc_sru = regno | (opcode << 3) | SRU_BIT;

  (*strp) += chars_read;

  return 0;
}

/* Parses modifiers and encodes as:

   13            7 6     4  3  2     0
   [i i i i i i i] [p p p] [F] [r r r]
          |           |     |     `-repeat count
          |           |      `-set flags
          |            `-lane predication
           `-SRU or ACC settings.
*/

static const char *
parse_vec80mods (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
                 const char **strp,
                 int opindex ATTRIBUTE_UNUSED,
                 unsigned long *valuep)
{
  unsigned long repeat = 0;
  unsigned long acc_sru = 0;
  unsigned long predication = 0;
  bfd_boolean setf = FALSE;
  bfd_boolean sru_p = FALSE;
  bfd_boolean acc_p = FALSE;

  while (**strp != 0)
    {
      if (**strp == ' ')
        (*strp)++;

      if (strncmp (*strp, "REP", 3) == 0)
        {
          if (repeat)
            return "multiple REP specifiers";

          (*strp) += 3;
          if (strncmp (*strp, "2", 1) == 0)
            repeat = 1, (*strp)++;
          else if (strncmp (*strp, "4", 1) == 0)
            repeat = 2, (*strp)++;
          else if (strncmp (*strp, "8", 1) == 0)
            repeat = 3, (*strp)++;
          else if (strncmp (*strp, "16", 2) == 0)
            repeat = 4, (*strp) += 2;
          else if (strncmp (*strp, "32", 2) == 0)
            repeat = 5, (*strp) += 2;
          else if (strncmp (*strp, "64", 2) == 0)
            repeat = 6, (*strp) += 2;
          else if (strncmp (*strp, " r0", 3) == 0)
            repeat = 7, (*strp) += 3;
          else
            return "bad repeat count";
        }
      else if (strncmp (*strp, "SETF", 4) == 0)
        {
          setf = TRUE;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "ALL", 3) == 0)
        {
          predication = 0;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "NONE", 4) == 0)
        {
          predication = 1;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "IFZ", 3) == 0)
        {
          predication = 2;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "IFNZ", 4) == 0)
        {
          predication = 3;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "IFN", 3) == 0)
        {
          predication = 4;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "IFNN", 4) == 0)
        {
          predication = 5;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "IFC", 3) == 0)
        {
          predication = 6;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "IFNC", 4) == 0)
        {
          predication = 7;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "ENA", 3) == 0)
        {
          if (sru_p)
            return "can't have ENA with SRU";
          acc_sru |= ENA_BIT;
          acc_p = TRUE;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "HIGH", 4) == 0)
        {
          if (sru_p)
            return "can't have HIGH with SRU";
          acc_sru |= HIGH_BIT;
          acc_p = TRUE;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "SIGN", 4) == 0)
        {
          if (sru_p)
            return "can't have SIGN with SRU";
          acc_sru |= SIGN_BIT;
          acc_p = TRUE;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "CLRA", 4) == 0)
        {
          if (sru_p)
            return "can't have CLRA with SRU";
          acc_sru |= CLRA_BIT;
          acc_p = TRUE;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "WBA", 3) == 0)
        {
          if (sru_p)
            return "can't have WBA with SRU";
          acc_sru |= WBA_BIT;
          acc_p = TRUE;
          (*strp) += 3;
        }
      else if (strncmp (*strp, "SUB", 3) == 0)
        {
          if (sru_p)
            return "can't have SUB with SRU";
          acc_sru |= SUB_BIT;
          acc_p = TRUE;
          (*strp) += 3;
        }
      else if (**strp
               && (strncmp ((*strp) + 1, "ACC", 3) == 0
                   || strncmp ((*strp) + 1, "ADD", 3) == 0))
        {
          if (sru_p)
            return "can't have ACC with SRU";
          acc_sru |= ENA_BIT;
          if (strncmp ((*strp) + 1, "ACC", 3) == 0)
            acc_sru |= WBA_BIT;
          if (**strp == 'S')
            acc_sru |= SIGN_BIT;
          else if (**strp != 'U')
            return "not UACC/SACC";
          if ((*strp)[4] == 'H')
            {
              acc_sru |= HIGH_BIT;
              (*strp)++;
            }
          acc_p = TRUE;
          (*strp) += 4;
        }
      else if (**strp
               && (strncmp ((*strp) + 1, "DEC", 3) == 0
                   || strncmp ((*strp) + 1, "SUB", 3) == 0))
        {
          if (sru_p)
            return "can't have DEC with SRU";
          acc_sru |= ENA_BIT;
          if (strncmp ((*strp) + 1, "DEC", 3) == 0)
            acc_sru |= WBA_BIT;
          if (**strp == 'S')
            acc_sru |= SIGN_BIT;
          else if (**strp != 'U')
            return "not UDEC/SDEC";
          if ((*strp)[4] == 'H')
            {
              acc_sru |= HIGH_BIT;
              (*strp)++;
            }
          acc_p = TRUE;
          (*strp) += 4;
        }
      else if (strncmp (*strp, "SUMS", 4) == 0
               || strncmp (*strp, "SUMU", 4) == 0)
        {
          int opcode = (*strp)[3] == 'S' ? 1 : 0;
          if (acc_p)
            return "can't have SUMS/SUMU with ACC";

          (*strp) += 4;

          if (parse_scalar_reg_update (strp, &acc_sru, opcode))
            return "error parsing scalar update reg";

          sru_p = TRUE;
        }
      else if (strncmp (*strp, "IMIN", 4) == 0)
        {
          if (acc_p)
            return "can't have IMIN with ACC";
          (*strp) += 4;
          if (parse_scalar_reg_update (strp, &acc_sru, 3))
            return "error parsing scalar update reg";
          sru_p = TRUE;
        }
      else if (strncmp (*strp, "IMAX", 4) == 0)
        {
          if (acc_p)
            return "can't have IMAX with ACC";
          (*strp) += 4;
          if (parse_scalar_reg_update (strp, &acc_sru, 5))
            return "error parsing scalar update reg";
          sru_p = TRUE;
        }
      else if (strncmp (*strp, "MAX", 3) == 0)
        {
          if (acc_p)
            return "can't have MAX with ACC";
          (*strp) += 3;
          if (parse_scalar_reg_update (strp, &acc_sru, 7))
            return "error parsing scalar update reg";
          sru_p = TRUE;
        }
      else
        return "unexpected modifier";
    }

  if (acc_p && sru_p)
    return "scalar reg update and accumulator ops";

  *valuep = repeat | (setf << 3) | (predication << 4) | (acc_sru << 7);

  return 0;
}

/* -- dis.c */

#define CGEN_PRINT_INSN vc4_print_insn

typedef enum
{
  VC4_STANDARD_INSN,
  VC4_SWITCH_CASES
} vc4_disassemble_state;

typedef struct
{
  vc4_disassemble_state disassemble_state;
  int table_entry_size;
  bfd_vma base_address;
} vc4_private_data;

static int
vc4_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
{
  bfd_byte buf[CGEN_MAX_INSN_SIZE];
  const int maxlen = 6;
  int buflen;
  int status;
  int insn;
  vc4_private_data *vc4_data = info->private_data;
  bfd_boolean symbol_here = (*info->symbol_at_address_func) (pc, info);

  if (info->private_data == NULL)
    vc4_data = info->private_data = calloc (sizeof (vc4_private_data), 1);

  info->bytes_per_line = buflen = maxlen;

  do
    {
      memset (buf, 0, 10);
      status = (*info->read_memory_func) (pc, buf, buflen, info);
      buflen -= 2;
    }
  while (status != 0 && buflen > 0);

  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }

  if (symbol_here
      && vc4_data->disassemble_state == VC4_SWITCH_CASES
      && pc > vc4_data->base_address)
    vc4_data->disassemble_state = VC4_STANDARD_INSN;

  switch (vc4_data->disassemble_state)
    {
    case VC4_STANDARD_INSN:
      {
        insn = buf[0] | (buf[1] << 8);

        if ((insn & 0xffc0) == 0x0080)
          {
            /* If there's a label right after this switch statement, start
               disassembling as switch cases instead of instructions.  This
               won't work for disassembling files without symbols!  */
            if ((*info->symbol_at_address_func) (pc + 2, info))
              vc4_data->disassemble_state = VC4_SWITCH_CASES;

            vc4_data->table_entry_size = (insn & 0x20) ? 2 : 1;
            vc4_data->base_address = pc + 2;
          }
      }
      break;

    case VC4_SWITCH_CASES:
      {
        bfd_vma target;
        bfd_signed_vma offset;

        switch (vc4_data->table_entry_size)
          {
          case 1:
            offset = buf[0];
            if (offset & 0x80)
              offset -= 0x100;
            break;
          case 2:
            offset = buf[0] | (buf[1] << 8);
            if (offset & 0x8000)
              offset -= 0x10000;
            break;
          default:
            abort ();
          }

        target = vc4_data->base_address + 2 * offset;

        info->fprintf_func (info->stream, ".case ");
        (*info->print_address_func) (target, info);

        return vc4_data->table_entry_size;
      }
      break;
    }

  return print_insn (cd, pc, info, buf, 6);
}

#define PRINT_SHLN(N)                                           \
  static void                                                   \
  print_shl##N (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,              \
	        void * dis_info,                                \
	        long value ATTRIBUTE_UNUSED,                    \
	        unsigned int attrs ATTRIBUTE_UNUSED,            \
	        bfd_vma pc ATTRIBUTE_UNUSED,                    \
	        int length ATTRIBUTE_UNUSED)                    \
  {                                                             \
    disassemble_info *info = (disassemble_info *) dis_info;     \
    (*info->fprintf_func) (info->stream, "<<" #N);              \
  }

PRINT_SHLN(1)
PRINT_SHLN(2)
PRINT_SHLN(3)
PRINT_SHLN(4)
PRINT_SHLN(5)
PRINT_SHLN(6)
PRINT_SHLN(7)
PRINT_SHLN(8)

/* Vector insn printing.  */

static void
print_vector_reg (void *dis_info, unsigned long value, bfd_boolean areg_p)
{
  vc4_vec_dir vec_dir;
  unsigned x, y;
  bfd_boolean do_inc, column_offset;
  unsigned scalar_reg;
  disassemble_info *info = (disassemble_info *) dis_info;
  const char *typename;

  switch ((value >> 6) & 15)
    {
    case 0: case 2: case 4: case 6:
      vec_dir = H;
      x = ((value >> 7) & 3) << 4;
      if (areg_p)
        x |= (value >> 16) & 15;
      y = value & 63;
      break;
    case 8: case 10:
      vec_dir = HX;
      x = ((value >> 7) & 1) << 5;
      if (areg_p)
        x |= (value >> 16) & 15;
      y = value & 63;
      break;
    case 12:
      vec_dir = HY;
      x = 0;
      if (areg_p)
        x |= (value >> 16) & 15;
      y = value & 63;
      break;

    case 1: case 3: case 5: case 7:
      vec_dir = V;
      if (!areg_p)
        {
          x = ((value >> 7) & 3) << 4;
          x |= value & 15;
          y = value & 0x30;
        }
      else
        {
          x = ((value >> 7) & 3) << 4;
          x |= (value >> 16) & 15;
          y = value & 0x3f;
        }
      break;
    case 9: case 11:
      vec_dir = VX;
      if (!areg_p)
        {
          x = ((value >> 7) & 1) << 5;
          x |= value & 15;
          y = value & 0x30;
        }
      else
        {
          x = ((value >> 7) & 1) << 5;
          x |= (value >> 16) & 15;
          y = value & 0x3f;
        }
      break;
    case 13:
      vec_dir = VY;
      if (!areg_p)
        {
          x = value & 15;
          y = value & 0x30;
        }
      else
        {
          x = (value >> 16) & 15;
          y = value & 0x3f;
        }
      break;

    default:
      vec_dir = DASH;
      x = y = 0;
      break;
    }

  column_offset = (value >> 10) & 1;
  do_inc = (value >> 11) & 1;
  scalar_reg = (value >> 12) & 15;

  switch (vec_dir)
    {
    case H: typename = "H"; break;
    case HX: typename = "HX"; break;
    case HY: typename = "HY"; break;
    case V: typename = "V"; break;
    case VX: typename = "VX"; break;
    case VY: typename = "VY"; break;
    case DASH:
      (*info->fprintf_func) (info->stream, "-");
      return;
    }

  (*info->fprintf_func) (info->stream, "%s(%u", typename, y);
  if ((vec_dir == H || vec_dir == HX || vec_dir == HY)
      && do_inc)
    (*info->fprintf_func) (info->stream, "++");

  (*info->fprintf_func) (info->stream, ",%u", x);
  if ((vec_dir == V || vec_dir == VX || vec_dir == VY)
      && do_inc)
    (*info->fprintf_func) (info->stream, "++");

  (*info->fprintf_func) (info->stream, ")");

  if (scalar_reg != 15)
    (*info->fprintf_func) (info->stream, "+r%u", scalar_reg);

  if (column_offset)
    (*info->fprintf_func) (info->stream, "*");
}

static void
print_vec80aludreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	            void * dis_info,
	            unsigned long value,
	            unsigned int attrs ATTRIBUTE_UNUSED,
	            bfd_vma pc ATTRIBUTE_UNUSED,
	            int length ATTRIBUTE_UNUSED)
{
  print_vector_reg (dis_info, value, FALSE);
}

static void
print_vec80aluareg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	            void * dis_info,
	            unsigned long value,
	            unsigned int attrs ATTRIBUTE_UNUSED,
	            bfd_vma pc ATTRIBUTE_UNUSED,
	            int length ATTRIBUTE_UNUSED)
{
  print_vector_reg (dis_info, value, TRUE);
}

static void
print_vec80alubreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	            void * dis_info,
	            unsigned long value,
	            unsigned int attrs ATTRIBUTE_UNUSED,
	            bfd_vma pc ATTRIBUTE_UNUSED,
	            int length ATTRIBUTE_UNUSED)
{
  print_vector_reg (dis_info, value, FALSE);
}

static void
print_vec80mods (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	         void * dis_info ATTRIBUTE_UNUSED,
	         unsigned long value ATTRIBUTE_UNUSED,
	         unsigned int attrs ATTRIBUTE_UNUSED,
	         bfd_vma pc ATTRIBUTE_UNUSED,
	         int length ATTRIBUTE_UNUSED)
{
}

/* -- */

