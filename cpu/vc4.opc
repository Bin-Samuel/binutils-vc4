/* -- opc.h */

/* Most bits in the first word are variable, but we can at least hash on
   coarse instruction types, which is better than nothing.  */

#define CGEN_DIS_HASH_SIZE 8
#define CGEN_DIS_HASH(buf, value)					\
  ((((unsigned char *) buf)[1] & 0x80) == 0 ? 0      /* scalar16.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf8 ? 1 /* vector80.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf0 ? 2 /* vector48.  */	\
   : (((unsigned char *) buf)[1] & 0xf0) == 0xe0 ? 3 /* scalar48.  */	\
   : 4)						     /* scalar32.  */

#define CGEN_ASM_HASH_SIZE 5

/* -- asm.c */

#include <errno.h>

union floatbits {
  float f;
  uint32_t u;
};

static const char *
parse_floatimm6 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 const char **strp,
		 int opindex ATTRIBUTE_UNUSED,
		 unsigned long *valuep)
{
  const char *startptr = *strp;
  char *endptr;
  union floatbits val;
  unsigned int exponent, signbit, mantissa;

  errno = 0;
  val.f = (float) strtod (startptr, &endptr);

  if (errno != 0)
    goto err_out;

  signbit = (val.u & 0x80000000) ? 1 : 0;
  exponent = (val.u >> 23) & 0xff;
  mantissa = val.u & 0x7fffff;

  if (exponent >= 124 && exponent < 132
      && (mantissa & 0x1fffff) == 0)
    {
      exponent -= 124;
      *valuep = (signbit << 5) | (exponent << 2) | (mantissa >> 21);
      *strp = endptr;
      return NULL;
    }

err_out:
  return "Bad floating-point immediate";
}

static const char *
parse_uimm5_shl3 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);

  if (!errmsg && ((*valuep & 7) != 0 || *valuep > 248))
    errmsg = "out-of-range immediate";

  return errmsg;
}

static const char *
parse_shifted_imm (CGEN_CPU_DESC cd, const char **strp, int opindex,
		   long *valuep, unsigned bits, unsigned shift)
{
  const char *errmsg;
  unsigned mask = (1 << shift) - 1;
  long lo = -(1 << (bits - 1)), hi = 1 << (bits - 1);
  long value;

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);

  if (!errmsg && ((value & mask) != 0 || (value >> shift) < lo
		  || (value >> shift) >= hi))
    errmsg = "out-of-range immediate";
  else
    *valuep = value;

  return errmsg;
}

#define SHIFTED_IMM_FN(B,S)						\
  static const char *							\
  parse_imm##B##_shl##S (CGEN_CPU_DESC cd, const char **strp,		\
			 int opindex, long *valuep)			\
  {									\
    return parse_shifted_imm (cd, strp, opindex, valuep, (B), (S));	\
  }

SHIFTED_IMM_FN (6, 8)
SHIFTED_IMM_FN (6, 7)
SHIFTED_IMM_FN (6, 6)
SHIFTED_IMM_FN (6, 5)
SHIFTED_IMM_FN (6, 4)
SHIFTED_IMM_FN (6, 3)
SHIFTED_IMM_FN (6, 2)
SHIFTED_IMM_FN (6, 1)

SHIFTED_IMM_FN (16, 4)
SHIFTED_IMM_FN (16, 3)
SHIFTED_IMM_FN (16, 2)
SHIFTED_IMM_FN (16, 1)

static const char *
parse_imm12 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 12, 0);
}

static const char *
parse_imm16 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 16, 0);
}

/* -- */

