/* -- opc.h */

/* Most bits in the first word are variable, but we can at least hash on
   coarse instruction types, which is better than nothing.  */

#define CGEN_DIS_HASH_SIZE 8
#define CGEN_DIS_HASH(buf, value)					\
  ((((unsigned char *) buf)[1] & 0x80) == 0 ? 0      /* scalar16.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf8 ? 1 /* vector80.  */	\
   : (((unsigned char *) buf)[1] & 0xf8) == 0xf0 ? 2 /* vector48.  */	\
   : (((unsigned char *) buf)[1] & 0xf0) == 0xe0 ? 3 /* scalar48.  */	\
   : 4)						     /* scalar32.  */

#define CGEN_ASM_HASH_SIZE 5

/* -- asm.c */

#include <errno.h>

union floatbits {
  float f;
  uint32_t u;
};

static const char *
parse_floatimm6 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 const char **strp,
		 int opindex ATTRIBUTE_UNUSED,
		 unsigned long *valuep)
{
  const char *startptr;
  char *endptr;
  union floatbits val;
  unsigned int exponent, signbit, mantissa;

  if (**strp == '#')
    (*strp)++;

  startptr = *strp;

  errno = 0;
  val.f = (float) strtod (startptr, &endptr);

  if (errno != 0)
    goto err_out;

  signbit = (val.u & 0x80000000) ? 1 : 0;
  exponent = (val.u >> 23) & 0xff;
  mantissa = val.u & 0x7fffff;

  if (exponent >= 124 && exponent < 132
      && (mantissa & 0x1fffff) == 0)
    {
      exponent -= 124;
      *valuep = (signbit << 5) | (exponent << 2) | (mantissa >> 21);
      *strp = endptr;
      return NULL;
    }

err_out:
  return "Bad floating-point immediate";
}

static const char *
parse_shifted_uimm (CGEN_CPU_DESC cd, const char **strp, int opindex,
		    unsigned long *valuep, unsigned bits, unsigned shift)
{
  const char *errmsg;
  unsigned mask = (1 << shift) - 1;
  unsigned long hi = 1 << bits;
  enum cgen_parse_operand_result result_type;
  unsigned long value;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  /* Ambiguity resolution: (rN++) looks like adding an expression "+", which
     fails to parse as an address.  */
  if (**strp == '+')
    return "post-inc";

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  if (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER)
    return "use wider reloc";

  value = result;

  if (!errmsg && ((value & mask) != 0 || (value >> shift) >= hi))
    errmsg = "out-of-range immediate";
  else
    *valuep = value;

  return errmsg;
}

static const char *
parse_uimm5 (CGEN_CPU_DESC cd, const char **strp, int opindex,
	     unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 0);
}

static const char *
parse_uimm4_shl2 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 4, 2);
}

static const char *
parse_uimm5_shl2 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 2);
}

static const char *
parse_uimm5_shl3 (CGEN_CPU_DESC cd, const char **strp, int opindex,
		  unsigned long *valuep)
{
  return parse_shifted_uimm (cd, strp, opindex, valuep, 5, 3);
}

static const char *
parse_shifted_imm (CGEN_CPU_DESC cd, const char **strp, int opindex,
		   long *valuep, unsigned bits, unsigned shift)
{
  const char *errmsg;
  unsigned mask = (1 << shift) - 1;
  long lo = -(1 << (bits - 1)), hi = 1 << (bits - 1);
  enum cgen_parse_operand_result result_type;
  long value;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  /* Ambiguity resolution: (rN++) looks like adding an expression "+", which
     fails to parse as an address.  */
  if (**strp == '+')
    return "post-inc";

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  if (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER)
    return "use wider reloc";

  if (result & 0x80000000)
    result |= ~(bfd_vma) 0xffffffff;

  value = (bfd_signed_vma) result;

  if (!errmsg && ((value & mask) != 0 || (value >> shift) < lo
		  || (value >> shift) >= hi))
    errmsg = "out-of-range immediate";
  else
    *valuep = value;

  return errmsg;
}

#define SHIFTED_IMM_FN(B,S)						\
  static const char *							\
  parse_imm##B##_shl##S (CGEN_CPU_DESC cd, const char **strp,		\
			 int opindex, long *valuep)			\
  {									\
    return parse_shifted_imm (cd, strp, opindex, valuep, (B), (S));	\
  }

SHIFTED_IMM_FN (6, 8)
SHIFTED_IMM_FN (6, 7)
SHIFTED_IMM_FN (6, 6)
SHIFTED_IMM_FN (6, 5)
SHIFTED_IMM_FN (6, 4)
SHIFTED_IMM_FN (6, 3)
SHIFTED_IMM_FN (6, 2)
SHIFTED_IMM_FN (6, 1)

SHIFTED_IMM_FN (16, 4)
SHIFTED_IMM_FN (16, 3)
SHIFTED_IMM_FN (16, 2)
SHIFTED_IMM_FN (16, 1)

static const char *
parse_imm4 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 4, 0);
}

static const char *
parse_imm6 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 6, 0);
}

static const char *
parse_imm12 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 12, 0);
}

static const char *
parse_imm16 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 16, 0);
}

static const char *
parse_imm27 (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
{
  return parse_shifted_imm (cd, strp, opindex, valuep, 27, 0);
}

static const char *
parse_imm32 (CGEN_CPU_DESC cd, const char **strp, int opindex,
             unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma result;

  if (**strp == '#')
    (*strp)++;

  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE, &result_type,
                               &result);

  if (errmsg)
    return errmsg;

  *valuep = (unsigned long) result;

  return 0;
}

static const char *
parse_pcrel27 (CGEN_CPU_DESC cd, const char **strp, int opindex,
	       bfd_reloc_code_real_type code,
	       enum cgen_parse_operand_result *result_type, bfd_vma *valuep)
{
  bfd_vma result;
  const char *errmsg;

  /* Instructions like "st r5,(lr)" are ambiguous since "lr" can be interpreted
     as a bracketed symbolic name when we meant it to be parsed as a register
     indirection.  Special-case the former to fail.  */
  if (**strp == '(')
    {
      const char *s = *strp;

      if (s[0] == '-' && s[1] == '-')
        return "looks like predec";

      while (ISALNUM (*++s))
        ;

      if (s[0] == '+' && s[1] == '+')
        return "looks like postinc";

      if (*s == ')')
        return "looks like indirection";
    }

  errmsg = cgen_parse_address (cd, strp, opindex, code, result_type, &result);

  if (!errmsg)
    *valuep = result;

  return errmsg;
}

static const char *
parse_shlN (CGEN_CPU_DESC cd, const char **strp,
            int opindex,
            unsigned long *valuep ATTRIBUTE_UNUSED,
            unsigned long shift)
{
  const char *scan = *strp;
  bfd_boolean is_multiply = FALSE;
  const char *errmsg;
  unsigned long uval;

  while (ISSPACE (*scan))
    scan++;

  if (strncmp (scan, "shl", 3) == 0
      || strncmp (scan, "lsl", 3) == 0)
    scan += 3;
  else if (strncmp (scan, "<<", 2) == 0)
    scan += 2;
  else if (strncmp (scan, "*", 1) == 0)
    {
      scan++;
      is_multiply = TRUE;
    }
  else
    return "no left shift";

  while (ISSPACE (*scan))
    scan++;

  if (!is_multiply && *scan == '#')
    scan++;

  *strp = scan;
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &uval);

  if (errmsg)
    return errmsg;

  if ((is_multiply && uval == (1ul << shift))
      || (!is_multiply && uval == shift))
    return 0;

  return "wrong shift amount";
}

#define PARSE_SHLN(N)                                             \
  static const char *                                             \
  parse_shl##N (CGEN_CPU_DESC cd, const char **strp, int opindex, \
                unsigned long *valuep)                            \
  {                                                               \
    return parse_shlN (cd, strp, opindex, valuep, (N));           \
  }

PARSE_SHLN(1)
PARSE_SHLN(2)
PARSE_SHLN(3)
PARSE_SHLN(4)
PARSE_SHLN(5)
PARSE_SHLN(6)
PARSE_SHLN(7)
PARSE_SHLN(8)

/* -- dis.c */

#define PRINT_SHLN(N)                                           \
  static void                                                   \
  print_shl##N (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,              \
	        void * dis_info,                                \
	        long value ATTRIBUTE_UNUSED,                    \
	        unsigned int attrs ATTRIBUTE_UNUSED,            \
	        bfd_vma pc ATTRIBUTE_UNUSED,                    \
	        int length ATTRIBUTE_UNUSED)                    \
  {                                                             \
    disassemble_info *info = (disassemble_info *) dis_info;     \
    (*info->fprintf_func) (info->stream, "<<" #N);              \
  }

PRINT_SHLN(1)
PRINT_SHLN(2)
PRINT_SHLN(3)
PRINT_SHLN(4)
PRINT_SHLN(5)
PRINT_SHLN(6)
PRINT_SHLN(7)
PRINT_SHLN(8)

/* -- */

